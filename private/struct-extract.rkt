#lang racket/base

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide p/c-remove-structs!)

(require racket/require
         (multi-in racket (list set syntax string function math))
         mischief/dict
         syntax/parse
         scv-cr/private/syntax-util)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; An S/F-Hash is a [Hash Syntax [List-of Syntax]] mapping structs names to their
;; fields.

;; An S/C-Hash is a [Hash Syntax [List-of [List-of Syntax Syntax]]] mapping struct
;; names their field-contract mapping.

;; An S/O-Hash is a [Hash Syntax Syntax] mapping struct names to their struct-out
;; specification.

;; A Struct-Proc is a (Syntax [List-of Syntax] -> [List-of Syntax]) that returns
;; some subset of all the exports generated by a struct definition.

;; A Struct-Pred is a (Syntax -> Syntax or #f) that can determine if an
;; identifier a certain type of struct export and returns the corresponding
;; struct name or #f.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; I/C-Hash P/C-Hash Symbol Syntax -> S/O-Hash
;; modifies p/c-hash removing struct-related exports and returns
;; an s/o-hash
(define (p/c-remove-structs! i/c-hash p/c-hash key stx-raw)
  (define-values (s/f-hash s/s-hash)
    (s/f-make key stx-raw))
  (let* ([export?  (s/f-export? s/f-hash)]
         [ctor?    (curry unstrange s/f-hash)]
         [s/c-hash (make-hash)])
    (hash-for-each
     p/c-hash
     (λ (id ctc)
       (when (export? id)
         (hash-remove! p/c-hash id))
       (when (ctor? id)
         (s/c-add! s/c-hash i/c-hash s/f-hash s/s-hash id ctc))))
    (s/o-make s/c-hash s/s-hash)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Symbol Syntax -> S/F-Hash S/S-Hash
;; takes Typed Racket syntax and returns hash that maps struct names to their
;; fields
(define (s/f-make key stx-raw)
  (define s/f-hash (make-hash))
  (define s/s-hash (make-hash))
  (let go ([stx stx-raw])
    (syntax-parse stx
      #:datum-literals (struct struct: :)
      [((~or struct struct:) s:struct-name-splicing ((fld : type) ...) _ ...)
       (hash-set! s/f-hash #'s.name (syntax-e #'(fld ...)))
       (when (syntax-e #'s.super)
         (hash-set! s/s-hash #'s.name #'s.super))
       stx]
      [((~datum #:struct) s:struct-name ((fld : type) ...) _ ...)
       (hash-set! s/f-hash #'s.name (syntax-e #'(fld ...)))
       (when (syntax-e #'s.super)
         (hash-set! s/s-hash #'s.name #'s.super))
       stx]
      [(x ...)
       (for-each go (syntax-e #'(x ...)))
       stx]
      [_ stx]))
  (values s/f-hash s/s-hash))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; S/C-Hash I/C-Hash S/F-Hash S/S-Hash Syntax Syntax -> Void
;; takes pair matching constructor with contract and pushes appropriate
;; field-to-contract association into s/c-hash
(define (s/c-add! s/c-hash i/c-hash s/f-hash s/s-hash id ctc)
  (let* ([id*      (unstrange s/f-hash id)]
         [fld-ctcs (chase-domain ctc i/c-hash)]
         [s-n      (super-fields s/f-hash s/s-hash id*)]
         [f/c-list (map list
                        (hash-ref s/f-hash id*)
                        (drop fld-ctcs s-n))])
    (hash-set! s/c-hash id* f/c-list)))

;; S/F-Hash S/S-Hash Syntax -> Natural
;; returns the number of super struct fields present in the constructor
(define (super-fields s/f-hash s/s-hash id)
  (let go ([id  id]
           [acc 0])
    (define super (hash-ref-stx s/s-hash id))
    (if super
        (go super (+ acc (length (hash-ref-stx s/f-hash super))))
        acc)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Struct-Hash S/S-Hash -> [List-of Syntax]
;; returns list of struct-out declarations for contract-out
(define (s/o-make s/c-hash s/s-hash)
  (define s/o-hash (make-hash))
  (hash-for-each
   s/c-hash
   (λ (name f/c)
     (define super (hash-ref-stx s/s-hash name))
     (hash-set! s/o-hash
                (syntax-within
                 (datum->syntax #f
                                (if super
                                    (list name super)
                                    name))
                 name)
                (syntax-within
                 (datum->syntax #f
                                (get-f/c s/c-hash s/s-hash name))
                 name))))
  s/o-hash)

;; S/C-Hash S/S-Hash Syntax -> [List-of Syntax]
;; gets field contract association
(define (get-f/c s/c-hash s/s-hash name)
  (let go ([name name]
           [acc '()])
    (define super (hash-ref-stx s/s-hash name))
    (define acc* (append (hash-ref-stx s/c-hash name) acc))
    (if super
        (go super acc*)
        acc*)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Struct-Proc -> S/F-Hash -> Stuct-Pred
;; returns a predicate that can determine if an identifier is
;; that kind of export for the given mapping, returning which
;; struct it belonged to or #f
(define ((struct-proc->struct-pred sp) s/f-hash)
  (define exports
    (hash-map s/f-hash
              (λ (name flds)
                (map (λ (fld) (cons (syntax-e fld)
                                    (syntax-e name)))
                     (sp name flds)))))
  (define exports* (apply append exports))
  (λ (id)
    (assoc (syntax-e id) exports*)))

;; Struct-Proc
(define (struct-exports id flds)
  (append (list id
                (format-id id "~a?" id)
                (format-id id "struct:~a" id))
          (struct-accessors id flds)
          (struct-mutators id flds)))
(define (struct-accessors id flds)
  (map (λ (fld) (format-id id "~a-~a" id fld))
       flds))
(define (struct-mutators id flds)
  (map (λ (fld) (format-id id "set-~a-~a!" id fld))
       flds))

;; Struct-Pred
(define ((s/f-export? s/f-hash) id)
  (or (((struct-proc->struct-pred struct-exports) s/f-hash) id)
      (unstrange s/f-hash id)))
(define s/f-accessor?
  (struct-proc->struct-pred struct-accessors))
(define s/f-mutator?
  (struct-proc->struct-pred struct-mutators))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Syntax I/C-Hash -> Syntax
;; returns domain of the given definition through layers of definitional
;; indirection
(define (chase-domain i i/c-hash)
  (syntax-parse i
    #:datum-literals (->)
    [(-> x ... _) (syntax-e #'(x ...))]
    [x            (chase-domain (hash-ref-stx i/c-hash i) i/c-hash)]))

;; S/F-Hash Syntax -> Syntax
;; returns name of correct constructor from a strange one
(define (unstrange s/f-hash id)
  (define id* (syntax->string id))
  (findf (λ (name)
           (define name* (syntax->string name))
           (or (string=? id* name*)
               (and (string-prefix? id* name*)
                    (let [(n (string->number (substring id* (string-length name*))))]
                      (and n (natural? n))))))
         (hash-keys s/f-hash)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#;(module+ test
  (require rackunit)

  (define posn-hash
    (make-hash '((posn . (x y z)))))

  (test-case
    "extract-structs"
    (check-equal?
     (extract-structs
      'provide
      #'(module root typed/racket/base
          (struct: posn ((x : Real) (y : Real) (z : Real)))))
     posn-hash)

    (check-equal?
     (extract-structs
      'require-rename
      #'(module root typed/racket/base
          (require/typed/check "streams.rkt"
            [#:struct posn ([x : Real] [y : Real] [z : Real])])))
     posn-hash)
    )

  (test-case
    "struct-exports"
    (check-equal?
     (struct-exports 'posn '(x y z))
     '(posn
       posn?
       struct:posn
       posn-x posn-y posn-z
       set-posn-x! set-posn-y! set-posn-z!)))

  (define posn-export? (struct-export? posn-hash))
  (define posn-accessor? (struct-accessor? posn-hash))
  (define posn-mutator? (struct-mutator? posn-hash))

  (test-case
    "struct-export?"
    (check-equal? (posn-export? 'posn) 'posn)
    (check-equal? (posn-export? 'posn-x) 'posn)
    (check-false  (posn-export? 'posn-w))
    (check-equal? (posn-export? 'set-posn-y!) 'posn)
    (check-equal? (posn-export? 'posn?) 'posn)
    (check-equal? (posn-export? 'struct:posn) 'posn)
    )

  (test-case
    "struct-accessor?"
    (check-false  (posn-accessor? 'posn))
    (check-equal? (posn-accessor? 'posn-x) 'posn)
    (check-equal? (posn-accessor? 'posn-y) 'posn)
    (check-equal? (posn-accessor? 'posn-z) 'posn)
    (check-false  (posn-accessor? 'posn-w))
    (check-false (posn-accessor? 'set-posn-y!))
    (check-false (posn-accessor? 'posn?))
    (check-false (posn-accessor? 'struct:posn))
    )

  (test-case
    "struct-mutator?"
    (check-false  (posn-mutator? 'posn))
    (check-false (posn-mutator? 'posn-x))
    (check-false  (posn-mutator? 'posn-w))
    (check-equal? (posn-mutator? 'set-posn-x!) 'posn)
    (check-equal? (posn-mutator? 'set-posn-y!) 'posn)
    (check-equal? (posn-mutator? 'set-posn-z!) 'posn)
    (check-false (posn-mutator? 'posn?))
    (check-false (posn-mutator? 'struct:posn))
    )

  (test-case
    "struct-unstrange"
    (check-equal? (struct-unstrange posn-hash 'posn3) 'posn))
  )
